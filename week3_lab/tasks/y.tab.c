#define YY_parse_h_included
/*#define YY_USE_CLASS 
*/
/*  A Bison++ parser, made from parser.y  */

 /* with Bison++ version bison++ Version 1.21.9-1, adapted from GNU bison by coetmeur@icdc.fr
Maintained by Magnus Ekdahl <magnus@debian.org>
  */


#line 1 "/usr/share/bison++/bison.cc"
/* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */
/* Skeleton output parser for bison,
   Copyright (C) 1984, 1989, 1990 Bob Corbett and Richard Stallman

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 1, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  

   As a special exception, when this file is copied by Bison++ into a
   Bison++ output file, you may use that output file without restriction.
   This special exception was added by the Free Software Foundation
   in version 1.24 of Bison, and has been in Bison++ since 1.21.9.  

*/

/* HEADER SECTION */
#if defined( _MSDOS ) || defined(MSDOS) || defined(__MSDOS__) 
 #define __MSDOS_AND_ALIKE
#endif

#if defined(_WINDOWS) && defined(_MSC_VER)
 #define __HAVE_NO_ALLOCA
 #define __MSDOS_AND_ALIKE
#endif

#ifndef alloca
 #if defined( __GNUC__)
  #define alloca __builtin_alloca

 #elif (!defined (__STDC__) && defined (sparc)) || defined (__sparc__) || defined (__sparc)  || defined (__sgi)
  #include <alloca.h>

 #elif defined (__MSDOS_AND_ALIKE)
  #include <malloc.h>
  #ifndef __TURBOC__
   /* MS C runtime lib */
   #define alloca _alloca
  #endif

 #elif defined(_AIX)
  /* pragma must be put before any C/C++ instruction !! */
  #pragma alloca
  #include <malloc.h>

 #elif defined(__hpux)
  #ifdef __cplusplus
   extern "C" {
     void *alloca (unsigned int);
   };
  #else /* not __cplusplus */
   void *alloca ();
  #endif /* not __cplusplus */

 #endif /* not _AIX  not MSDOS, or __TURBOC__ or _AIX, not sparc.  */
#endif /* alloca not defined.  */

#ifdef c_plusplus
 #ifndef __cplusplus
  #define __cplusplus
 #endif
#endif

#ifdef __cplusplus
 #ifndef YY_USE_CLASS
/*#warning "For C++ its recomended to use bison++, otherwise classes won't be generated"*/
 #endif
#else
 #ifndef __STDC__
  #define const
 #endif
 #ifdef YY_USE_CLASS
  #error "This is a C++ header generated by bison++, please use a C++ compiler!"
 #endif
#endif

#include <stdio.h>
#define YYBISON 1  

 #line 88 "/usr/share/bison++/bison.cc"
#line 1 "parser.y"

	#include "sym_tab.h"
	#include <stdio.h>
	#include <stdlib.h>
	#include <string.h>
	void typTrack(int type);
	void lineTrack(int lno);

	void yyerror(char* s); // error handling function
	int yylex(); // declare the function performing lexical analysis
	extern int yylineno; // track the line number

	/*No need to use stack to track current line number and datatype of variable since in the LMD of tree expansion,after parsing the grammar for first variable,it goes to the second variable.*/

	//current data type while parsing
	int* currDatatype=NULL;
	//current line number of variable decleration during parsing
	int* currLineNumber=NULL;
	//manage curr scope
	int currScope = 1;
	//get sizeof datatype
	int size_of(int type);

	//function to declare variable
	symbol* declare_variable(char* varname);

	char* temp; //to store string version of integer
	char* temp2;;

	void intToString(int num);
	void floatToString(float num);

	int incrScope();
	int decrScope();

	//if we are processing a decleration statement
	int isDecl = 0;

#line 44 "parser.y"
typedef union{
	int dtype;
	int ival;
	float fval;
	char* varname;
	char* number;
	char* cval;
} yy_parse_stype;
#define YY_parse_STYPE yy_parse_stype
#ifndef YY_USE_CLASS
#define YYSTYPE yy_parse_stype
#endif

#line 88 "/usr/share/bison++/bison.cc"
/* %{ and %header{ and %union, during decl */
#define YY_parse_BISON 1

#ifndef YY_parse_COMPATIBILITY
 #ifndef YY_USE_CLASS
  #define  YY_parse_COMPATIBILITY 1
 #else
  #define  YY_parse_COMPATIBILITY 0
 #endif
#endif

#if YY_parse_COMPATIBILITY != 0
 /* backward compatibility */
 #ifdef YYLTYPE
  #ifndef YY_parse_LTYPE
   #define YY_parse_LTYPE YYLTYPE
  #endif
 #endif
/* Testing alternative bison solution
   /#ifdef YYSTYPE*/
#ifndef YY_parse_STYPE 
   #define YY_parse_STYPE YYSTYPE
#endif
/*#endif*/
 #ifdef YYDEBUG
  #ifndef YY_parse_DEBUG
   #define  YY_parse_DEBUG YYDEBUG
  #endif
 #endif
 
 /* use goto to be compatible */
 #ifndef YY_parse_USE_GOTO
  #define YY_parse_USE_GOTO 1
 #endif
#endif

/* use no goto to be clean in C++ */
#ifndef YY_parse_USE_GOTO
 #define YY_parse_USE_GOTO 0
#endif

#ifndef YY_parse_PURE

 #line 130 "/usr/share/bison++/bison.cc"

#line 130 "/usr/share/bison++/bison.cc"
/*  YY_parse_PURE */
#endif

/* section apres lecture def, avant lecture grammaire S2 */

 #line 134 "/usr/share/bison++/bison.cc"

#line 134 "/usr/share/bison++/bison.cc"
/* prefix */
#ifndef YY_parse_DEBUG

 #line 136 "/usr/share/bison++/bison.cc"

#line 136 "/usr/share/bison++/bison.cc"
/* YY_parse_DEBUG */
#endif


#ifndef YY_parse_LSP_NEEDED

 #line 141 "/usr/share/bison++/bison.cc"

#line 141 "/usr/share/bison++/bison.cc"
 /* YY_parse_LSP_NEEDED*/
#endif



/* DEFAULT LTYPE*/
#ifdef YY_parse_LSP_NEEDED
#ifndef YY_parse_LTYPE
#ifndef BISON_YYLTYPE_ISDECLARED
#define BISON_YYLTYPE_ISDECLARED
typedef
  struct yyltype
    {
      int timestamp;
      int first_line;
      int first_column;
      int last_line;
      int last_column;
      char *text;
   }
  yyltype;

#endif
#define YY_parse_LTYPE yyltype
#endif
#endif
/* DEFAULT STYPE*/
      /* We used to use `unsigned long' as YY_parse_STYPE on MSDOS,
	 but it seems better to be consistent.
	 Most programs should declare their own type anyway.  */

#ifndef YY_parse_STYPE
#define YY_parse_STYPE int
#endif
/* DEFAULT MISCELANEOUS */
#ifndef YY_parse_PARSE
#define YY_parse_PARSE yyparse
#endif
#ifndef YY_parse_LEX
#define YY_parse_LEX yylex
#endif
#ifndef YY_parse_LVAL
#define YY_parse_LVAL yylval
#endif
#ifndef YY_parse_LLOC
#define YY_parse_LLOC yylloc
#endif
#ifndef YY_parse_CHAR
#define YY_parse_CHAR yychar
#endif
#ifndef YY_parse_NERRS
#define YY_parse_NERRS yynerrs
#endif
#ifndef YY_parse_DEBUG_FLAG
#define YY_parse_DEBUG_FLAG yydebug
#endif
#ifndef YY_parse_ERROR
#define YY_parse_ERROR yyerror
#endif

#ifndef YY_parse_PARSE_PARAM
 #ifndef YY_USE_CLASS
  #ifdef YYPARSE_PARAM
   #define YY_parse_PARSE_PARAM void* YYPARSE_PARAM 
  #else
   #ifndef __STDC__
    #ifndef __cplusplus
     #define YY_parse_PARSE_PARAM
    #endif
   #endif
  #endif
 #endif
 #ifndef YY_parse_PARSE_PARAM
  #define YY_parse_PARSE_PARAM void
 #endif
#endif

#if YY_parse_COMPATIBILITY != 0
/* backward compatibility */
#ifdef YY_parse_LTYPE
#ifndef YYLTYPE
#define YYLTYPE YY_parse_LTYPE
#else
/* WARNING obsolete !!! user defined YYLTYPE not reported into generated header */
#endif
#endif

/* Removed due to bison compabilityproblems
/#ifndef YYSTYPE
/#define YYSTYPE YY_parse_STYPE
/#else*/
/* WARNING obsolete !!! user defined YYSTYPE not reported into generated header */
/*#endif*/

#ifdef YY_parse_PURE
#  ifndef YYPURE
#    define YYPURE YY_parse_PURE
#  endif
#endif

#ifdef YY_parse_DEBUG
#  ifndef YYDEBUG
#    define YYDEBUG YY_parse_DEBUG 
#  endif
#endif

#ifndef YY_parse_ERROR_VERBOSE
 #ifdef YYERROR_VERBOSE
  #define YY_parse_ERROR_VERBOSE YYERROR_VERBOSE
 #endif
#endif

#ifndef YY_parse_LSP_NEEDED
#  ifdef YYLSP_NEEDED
#    define YY_parse_LSP_NEEDED YYLSP_NEEDED
#  endif
#endif

#endif

#ifndef YY_USE_CLASS
/* TOKEN C */

 #line 263 "/usr/share/bison++/bison.cc"
#define	T_INT	258
#define	T_CHAR	259
#define	T_DOUBLE	260
#define	T_WHILE	261
#define	T_INC	262
#define	T_DEC	263
#define	T_OROR	264
#define	T_ANDAND	265
#define	T_EQCOMP	266
#define	T_NOTEQUAL	267
#define	T_GREATEREQ	268
#define	T_LESSEREQ	269
#define	T_LEFTSHIFT	270
#define	T_RIGHTSHIFT	271
#define	T_PRINTLN	272
#define	T_STRING	273
#define	T_FLOAT	274
#define	T_BOOLEAN	275
#define	T_IF	276
#define	T_ELSE	277
#define	T_STRLITERAL	278
#define	T_DO	279
#define	T_INCLUDE	280
#define	T_HEADER	281
#define	T_MAIN	282
#define	T_ID	283
#define	T_NUM	284


#line 263 "/usr/share/bison++/bison.cc"
 /* #defines tokens */
#else
/* CLASS */
#ifndef YY_parse_CLASS
#define YY_parse_CLASS parse
#endif
#ifndef YY_parse_INHERIT
#define YY_parse_INHERIT
#endif
#ifndef YY_parse_MEMBERS
#define YY_parse_MEMBERS 
#endif
#ifndef YY_parse_LEX_BODY
#define YY_parse_LEX_BODY  
#endif
#ifndef YY_parse_ERROR_BODY
#define YY_parse_ERROR_BODY  
#endif
#ifndef YY_parse_CONSTRUCTOR_PARAM
#define YY_parse_CONSTRUCTOR_PARAM
#endif
#ifndef YY_parse_CONSTRUCTOR_CODE
#define YY_parse_CONSTRUCTOR_CODE
#endif
#ifndef YY_parse_CONSTRUCTOR_INIT
#define YY_parse_CONSTRUCTOR_INIT
#endif
/* choose between enum and const */
#ifndef YY_parse_USE_CONST_TOKEN
#define YY_parse_USE_CONST_TOKEN 0
/* yes enum is more compatible with flex,  */
/* so by default we use it */ 
#endif
#if YY_parse_USE_CONST_TOKEN != 0
#ifndef YY_parse_ENUM_TOKEN
#define YY_parse_ENUM_TOKEN yy_parse_enum_token
#endif
#endif

class YY_parse_CLASS YY_parse_INHERIT
{
public: 
#if YY_parse_USE_CONST_TOKEN != 0
/* static const int token ... */

 #line 307 "/usr/share/bison++/bison.cc"
static const int T_INT;
static const int T_CHAR;
static const int T_DOUBLE;
static const int T_WHILE;
static const int T_INC;
static const int T_DEC;
static const int T_OROR;
static const int T_ANDAND;
static const int T_EQCOMP;
static const int T_NOTEQUAL;
static const int T_GREATEREQ;
static const int T_LESSEREQ;
static const int T_LEFTSHIFT;
static const int T_RIGHTSHIFT;
static const int T_PRINTLN;
static const int T_STRING;
static const int T_FLOAT;
static const int T_BOOLEAN;
static const int T_IF;
static const int T_ELSE;
static const int T_STRLITERAL;
static const int T_DO;
static const int T_INCLUDE;
static const int T_HEADER;
static const int T_MAIN;
static const int T_ID;
static const int T_NUM;


#line 307 "/usr/share/bison++/bison.cc"
 /* decl const */
#else
enum YY_parse_ENUM_TOKEN { YY_parse_NULL_TOKEN=0

 #line 310 "/usr/share/bison++/bison.cc"
	,T_INT=258
	,T_CHAR=259
	,T_DOUBLE=260
	,T_WHILE=261
	,T_INC=262
	,T_DEC=263
	,T_OROR=264
	,T_ANDAND=265
	,T_EQCOMP=266
	,T_NOTEQUAL=267
	,T_GREATEREQ=268
	,T_LESSEREQ=269
	,T_LEFTSHIFT=270
	,T_RIGHTSHIFT=271
	,T_PRINTLN=272
	,T_STRING=273
	,T_FLOAT=274
	,T_BOOLEAN=275
	,T_IF=276
	,T_ELSE=277
	,T_STRLITERAL=278
	,T_DO=279
	,T_INCLUDE=280
	,T_HEADER=281
	,T_MAIN=282
	,T_ID=283
	,T_NUM=284


#line 310 "/usr/share/bison++/bison.cc"
 /* enum token */
     }; /* end of enum declaration */
#endif
public:
 int YY_parse_PARSE (YY_parse_PARSE_PARAM);
 virtual void YY_parse_ERROR(char *msg) YY_parse_ERROR_BODY;
#ifdef YY_parse_PURE
#ifdef YY_parse_LSP_NEEDED
 virtual int  YY_parse_LEX (YY_parse_STYPE *YY_parse_LVAL,YY_parse_LTYPE *YY_parse_LLOC) YY_parse_LEX_BODY;
#else
 virtual int  YY_parse_LEX (YY_parse_STYPE *YY_parse_LVAL) YY_parse_LEX_BODY;
#endif
#else
 virtual int YY_parse_LEX() YY_parse_LEX_BODY;
 YY_parse_STYPE YY_parse_LVAL;
#ifdef YY_parse_LSP_NEEDED
 YY_parse_LTYPE YY_parse_LLOC;
#endif
 int   YY_parse_NERRS;
 int    YY_parse_CHAR;
#endif
#if YY_parse_DEBUG != 0
 int YY_parse_DEBUG_FLAG;   /*  nonzero means print parse trace     */
#endif
public:
 YY_parse_CLASS(YY_parse_CONSTRUCTOR_PARAM);
public:
 YY_parse_MEMBERS 
};
/* other declare folow */
#if YY_parse_USE_CONST_TOKEN != 0

 #line 341 "/usr/share/bison++/bison.cc"
const int YY_parse_CLASS::T_INT=258;
const int YY_parse_CLASS::T_CHAR=259;
const int YY_parse_CLASS::T_DOUBLE=260;
const int YY_parse_CLASS::T_WHILE=261;
const int YY_parse_CLASS::T_INC=262;
const int YY_parse_CLASS::T_DEC=263;
const int YY_parse_CLASS::T_OROR=264;
const int YY_parse_CLASS::T_ANDAND=265;
const int YY_parse_CLASS::T_EQCOMP=266;
const int YY_parse_CLASS::T_NOTEQUAL=267;
const int YY_parse_CLASS::T_GREATEREQ=268;
const int YY_parse_CLASS::T_LESSEREQ=269;
const int YY_parse_CLASS::T_LEFTSHIFT=270;
const int YY_parse_CLASS::T_RIGHTSHIFT=271;
const int YY_parse_CLASS::T_PRINTLN=272;
const int YY_parse_CLASS::T_STRING=273;
const int YY_parse_CLASS::T_FLOAT=274;
const int YY_parse_CLASS::T_BOOLEAN=275;
const int YY_parse_CLASS::T_IF=276;
const int YY_parse_CLASS::T_ELSE=277;
const int YY_parse_CLASS::T_STRLITERAL=278;
const int YY_parse_CLASS::T_DO=279;
const int YY_parse_CLASS::T_INCLUDE=280;
const int YY_parse_CLASS::T_HEADER=281;
const int YY_parse_CLASS::T_MAIN=282;
const int YY_parse_CLASS::T_ID=283;
const int YY_parse_CLASS::T_NUM=284;


#line 341 "/usr/share/bison++/bison.cc"
 /* const YY_parse_CLASS::token */
#endif
/*apres const  */
YY_parse_CLASS::YY_parse_CLASS(YY_parse_CONSTRUCTOR_PARAM) YY_parse_CONSTRUCTOR_INIT
{
#if YY_parse_DEBUG != 0
YY_parse_DEBUG_FLAG=0;
#endif
YY_parse_CONSTRUCTOR_CODE;
};
#endif

 #line 352 "/usr/share/bison++/bison.cc"


#define	YYFINAL		75
#define	YYFLAG		-32768
#define	YYNTBASE	43

#define YYTRANSLATE(x) ((unsigned)(x) <= 284 ? yytranslate[x] : 63)

static const char yytranslate[] = {     0,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,    37,
    38,    35,    33,    31,    34,     2,    36,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,    30,    39,
    32,    40,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,    41,     2,    42,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     1,     2,     3,     4,     5,
     6,     7,     8,     9,    10,    11,    12,    13,    14,    15,
    16,    17,    18,    19,    20,    21,    22,    23,    24,    25,
    26,    27,    28,    29
};

#if YY_parse_DEBUG != 0
static const short yyprhs[] = {     0,
     0,     2,     5,     9,    13,    14,    15,    19,    23,    25,
    29,    31,    33,    35,    37,    39,    43,    47,    49,    53,
    57,    59,    63,    67,    69,    73,    75,    77,    79,    81,
    83,    85,    87,    89,    91,    92,   102,   104,   105,   108,
   111,   112,   115,   118,   119,   124,   126
};

static const short yyrhs[] = {    44,
     0,    56,    44,     0,    45,    30,    44,     0,    50,    30,
    44,     0,     0,     0,    46,    49,    47,     0,    47,    31,
    48,     0,    48,     0,    28,    32,    51,     0,    28,     0,
     3,     0,    19,     0,     5,     0,     4,     0,    28,    32,
    51,     0,    51,    55,    52,     0,    52,     0,    52,    33,
    53,     0,    52,    34,    53,     0,    53,     0,    53,    35,
    54,     0,    53,    36,    54,     0,    54,     0,    37,    51,
    38,     0,    28,     0,    29,     0,    23,     0,    14,     0,
    13,     0,    39,     0,    40,     0,    11,     0,    12,     0,
     0,    49,    27,    37,    58,    38,    41,    57,    59,    42,
     0,    47,     0,     0,    60,    59,     0,    61,    59,     0,
     0,    45,    30,     0,    50,    30,     0,     0,    41,    62,
    59,    42,     0,    51,     0,    50,     0
};

#endif

#if (YY_parse_DEBUG != 0) || defined(YY_parse_ERROR_VERBOSE) 
static const short yyrline[] = { 0,
    54,    57,    58,    59,    60,    63,    63,    67,    68,    71,
    97,   120,   121,   122,   123,   127,   164,   165,   176,   187,
   195,   207,   218,   233,   244,   247,   278,   288,   302,   303,
   304,   305,   306,   307,   312,   316,   318,   319,   322,   323,
   324,   327,   328,   331,   333,   335,   336
};

static const char * const yytname[] = {   "$","error","$illegal.","T_INT","T_CHAR",
"T_DOUBLE","T_WHILE","T_INC","T_DEC","T_OROR","T_ANDAND","T_EQCOMP","T_NOTEQUAL",
"T_GREATEREQ","T_LESSEREQ","T_LEFTSHIFT","T_RIGHTSHIFT","T_PRINTLN","T_STRING",
"T_FLOAT","T_BOOLEAN","T_IF","T_ELSE","T_STRLITERAL","T_DO","T_INCLUDE","T_HEADER",
"T_MAIN","T_ID","T_NUM","';'","','","'='","'+'","'-'","'*'","'/'","'('","')'",
"'<'","'>'","'{'","'}'","START","PROG","DECLR","@1","LISTVAR","VAR","TYPE","ASSGN",
"EXPR","E","T","F","REL_OP","MAIN","@2","EMPTY_LISTVAR","STMT","STMT_NO_BLOCK",
"BLOCK","@3","\37777777614"
};
#endif

static const short yyr1[] = {     0,
    43,    44,    44,    44,    44,    46,    45,    47,    47,    48,
    48,    49,    49,    49,    49,    50,    51,    51,    52,    52,
    52,    53,    53,    53,    54,    54,    54,    54,    55,    55,
    55,    55,    55,    55,    57,    56,    58,    58,    59,    59,
    59,    60,    60,    62,    61,    -1,    -1
};

static const short yyr2[] = {     0,
     1,     2,     3,     3,     0,     0,     3,     3,     1,     3,
     1,     1,     1,     1,     1,     3,     3,     1,     3,     3,
     1,     3,     3,     1,     3,     1,     1,     1,     1,     1,
     1,     1,     1,     1,     0,     9,     1,     0,     2,     2,
     0,     2,     2,     0,     4,     1,     1
};

static const short yydefact[] = {     5,
    12,    15,    14,    13,     0,     1,     0,     0,     0,     0,
     5,     0,     5,     0,     0,     5,     2,    28,    26,    27,
     0,    16,    18,    21,    24,     3,    11,     7,     9,    38,
     4,     0,    33,    34,    30,    29,    31,    32,     0,     0,
     0,     0,     0,     0,     0,    37,     0,    25,    17,    19,
    20,    22,    23,    10,     8,     0,    35,     6,    44,     0,
     0,     0,     6,     6,     6,    42,    43,    36,    39,    40,
     0,    45,     0,     0,     0
};

static const short yydefgoto[] = {    73,
     6,     7,     8,    28,    29,     9,    10,    22,    23,    24,
    25,    39,    11,    58,    47,    62,    63,    64,    65
};

static const short yypact[] = {     6,
-32768,-32768,-32768,-32768,   -19,-32768,    -6,    11,    -1,     9,
     6,    12,     6,    14,    10,     6,-32768,-32768,-32768,-32768,
    12,    -7,    19,    20,-32768,-32768,    22,    28,-32768,    14,
-32768,   -11,-32768,-32768,-32768,-32768,-32768,-32768,    12,    12,
    12,    12,    12,    12,    14,    28,    24,-32768,    19,    20,
    20,-32768,-32768,    -7,-32768,    23,-32768,    -5,-32768,    33,
    36,     8,    -5,    -5,    -5,-32768,-32768,-32768,-32768,-32768,
    25,-32768,    65,    68,-32768
};

static const short yypgoto[] = {-32768,
    35,   -46,-32768,    39,    26,    62,   -20,   -13,    34,    17,
    18,-32768,-32768,-32768,-32768,   -43,-32768,-32768,-32768
};


#define	YYLAST		73


static const short yytable[] = {    33,
    34,    35,    36,    33,    34,    35,    36,    32,     1,     2,
     3,    60,    12,     1,     2,     3,    60,    60,    60,    69,
    70,    71,     5,    13,     4,    15,    48,    37,    38,     4,
    54,    37,    38,     5,    18,    59,   -41,    61,    16,    19,
    20,    27,    61,    61,    61,    17,    30,    26,    21,    68,
    31,    40,    41,    44,    42,    43,    50,    51,    45,    52,
    53,    56,    66,    57,    74,    67,    72,    75,    46,    14,
    55,     0,    49
};

static const short yycheck[] = {    11,
    12,    13,    14,    11,    12,    13,    14,    21,     3,     4,
     5,    58,    32,     3,     4,     5,    63,    64,    65,    63,
    64,    65,    28,    30,    19,    27,    38,    39,    40,    19,
    44,    39,    40,    28,    23,    41,    42,    58,    30,    28,
    29,    28,    63,    64,    65,    11,    37,    13,    37,    42,
    16,    33,    34,    32,    35,    36,    40,    41,    31,    42,
    43,    38,    30,    41,     0,    30,    42,     0,    30,     8,
    45,    -1,    39
};

#line 352 "/usr/share/bison++/bison.cc"
 /* fattrs + tables */

/* parser code folow  */


/* This is the parser code that is written into each bison parser
  when the %semantic_parser declaration is not specified in the grammar.
  It was written by Richard Stallman by simplifying the hairy parser
  used when %semantic_parser is specified.  */

/* Note: dollar marks section change
   the next  is replaced by the list of actions, each action
   as one case of the switch.  */ 

#if YY_parse_USE_GOTO != 0
/* 
 SUPRESSION OF GOTO : on some C++ compiler (sun c++)
  the goto is strictly forbidden if any constructor/destructor
  is used in the whole function (very stupid isn't it ?)
 so goto are to be replaced with a 'while/switch/case construct'
 here are the macro to keep some apparent compatibility
*/
#define YYGOTO(lb) {yy_gotostate=lb;continue;}
#define YYBEGINGOTO  enum yy_labels yy_gotostate=yygotostart; \
                     for(;;) switch(yy_gotostate) { case yygotostart: {
#define YYLABEL(lb) } case lb: {
#define YYENDGOTO } } 
#define YYBEGINDECLARELABEL enum yy_labels {yygotostart
#define YYDECLARELABEL(lb) ,lb
#define YYENDDECLARELABEL  };
#else
/* macro to keep goto */
#define YYGOTO(lb) goto lb
#define YYBEGINGOTO 
#define YYLABEL(lb) lb:
#define YYENDGOTO
#define YYBEGINDECLARELABEL 
#define YYDECLARELABEL(lb)
#define YYENDDECLARELABEL 
#endif
/* LABEL DECLARATION */
YYBEGINDECLARELABEL
  YYDECLARELABEL(yynewstate)
  YYDECLARELABEL(yybackup)
/* YYDECLARELABEL(yyresume) */
  YYDECLARELABEL(yydefault)
  YYDECLARELABEL(yyreduce)
  YYDECLARELABEL(yyerrlab)   /* here on detecting error */
  YYDECLARELABEL(yyerrlab1)   /* here on error raised explicitly by an action */
  YYDECLARELABEL(yyerrdefault)  /* current state does not do anything special for the error token. */
  YYDECLARELABEL(yyerrpop)   /* pop the current state because it cannot handle the error token */
  YYDECLARELABEL(yyerrhandle)  
YYENDDECLARELABEL
/* ALLOCA SIMULATION */
/* __HAVE_NO_ALLOCA */
#ifdef __HAVE_NO_ALLOCA
int __alloca_free_ptr(char *ptr,char *ref)
{if(ptr!=ref) free(ptr);
 return 0;}

#define __ALLOCA_alloca(size) malloc(size)
#define __ALLOCA_free(ptr,ref) __alloca_free_ptr((char *)ptr,(char *)ref)

#ifdef YY_parse_LSP_NEEDED
#define __ALLOCA_return(num) \
            do { return( __ALLOCA_free(yyss,yyssa)+\
		    __ALLOCA_free(yyvs,yyvsa)+\
		    __ALLOCA_free(yyls,yylsa)+\
		   (num)); } while(0)
#else
#define __ALLOCA_return(num) \
            do { return( __ALLOCA_free(yyss,yyssa)+\
		    __ALLOCA_free(yyvs,yyvsa)+\
		   (num)); } while(0)
#endif
#else
#define __ALLOCA_return(num) do { return(num); } while(0)
#define __ALLOCA_alloca(size) alloca(size)
#define __ALLOCA_free(ptr,ref) 
#endif

/* ENDALLOCA SIMULATION */

#define yyerrok         (yyerrstatus = 0)
#define yyclearin       (YY_parse_CHAR = YYEMPTY)
#define YYEMPTY         -2
#define YYEOF           0
#define YYACCEPT        __ALLOCA_return(0)
#define YYABORT         __ALLOCA_return(1)
#define YYERROR         YYGOTO(yyerrlab1)
/* Like YYERROR except do call yyerror.
   This remains here temporarily to ease the
   transition to the new meaning of YYERROR, for GCC.
   Once GCC version 2 has supplanted version 1, this can go.  */
#define YYFAIL          YYGOTO(yyerrlab)
#define YYRECOVERING()  (!!yyerrstatus)
#define YYBACKUP(token, value) \
do                                                              \
  if (YY_parse_CHAR == YYEMPTY && yylen == 1)                               \
    { YY_parse_CHAR = (token), YY_parse_LVAL = (value);                 \
      yychar1 = YYTRANSLATE (YY_parse_CHAR);                                \
      YYPOPSTACK;                                               \
      YYGOTO(yybackup);                                            \
    }                                                           \
  else                                                          \
    { YY_parse_ERROR ("syntax error: cannot back up"); YYERROR; }   \
while (0)

#define YYTERROR        1
#define YYERRCODE       256

#ifndef YY_parse_PURE
/* UNPURE */
#define YYLEX           YY_parse_LEX()
#ifndef YY_USE_CLASS
/* If nonreentrant, and not class , generate the variables here */
int     YY_parse_CHAR;                      /*  the lookahead symbol        */
YY_parse_STYPE      YY_parse_LVAL;              /*  the semantic value of the */
				/*  lookahead symbol    */
int YY_parse_NERRS;                 /*  number of parse errors so far */
#ifdef YY_parse_LSP_NEEDED
YY_parse_LTYPE YY_parse_LLOC;   /*  location data for the lookahead     */
			/*  symbol                              */
#endif
#endif


#else
/* PURE */
#ifdef YY_parse_LSP_NEEDED
#define YYLEX           YY_parse_LEX(&YY_parse_LVAL, &YY_parse_LLOC)
#else
#define YYLEX           YY_parse_LEX(&YY_parse_LVAL)
#endif
#endif
#ifndef YY_USE_CLASS
#if YY_parse_DEBUG != 0
int YY_parse_DEBUG_FLAG;                    /*  nonzero means print parse trace     */
/* Since this is uninitialized, it does not stop multiple parsers
   from coexisting.  */
#endif
#endif



/*  YYINITDEPTH indicates the initial size of the parser's stacks       */

#ifndef YYINITDEPTH
#define YYINITDEPTH 200
#endif

/*  YYMAXDEPTH is the maximum size the stacks can grow to
    (effective only if the built-in stack extension method is used).  */

#if YYMAXDEPTH == 0
#undef YYMAXDEPTH
#endif

#ifndef YYMAXDEPTH
#define YYMAXDEPTH 10000
#endif


#if __GNUC__ > 1                /* GNU C and GNU C++ define this.  */
#define __yy_bcopy(FROM,TO,COUNT)       __builtin_memcpy(TO,FROM,COUNT)
#else                           /* not GNU C or C++ */

/* This is the most reliable way to avoid incompatibilities
   in available built-in functions on various systems.  */

#ifdef __cplusplus
static void __yy_bcopy (char *from, char *to, int count)
#else
#ifdef __STDC__
static void __yy_bcopy (char *from, char *to, int count)
#else
static void __yy_bcopy (from, to, count)
     char *from;
     char *to;
     int count;
#endif
#endif
{
  register char *f = from;
  register char *t = to;
  register int i = count;

  while (i-- > 0)
    *t++ = *f++;
}
#endif


int
#ifdef YY_USE_CLASS
 YY_parse_CLASS::
#endif
     YY_parse_PARSE(YY_parse_PARSE_PARAM)
#ifndef __STDC__
#ifndef __cplusplus
#ifndef YY_USE_CLASS
/* parameter definition without protypes */
YY_parse_PARSE_PARAM_DEF
#endif
#endif
#endif
{
  register int yystate;
  register int yyn;
  register short *yyssp;
  register YY_parse_STYPE *yyvsp;
  int yyerrstatus;      /*  number of tokens to shift before error messages enabled */
  int yychar1=0;          /*  lookahead token as an internal (translated) token number */

  short yyssa[YYINITDEPTH];     /*  the state stack                     */
  YY_parse_STYPE yyvsa[YYINITDEPTH];        /*  the semantic value stack            */

  short *yyss = yyssa;          /*  refer to the stacks thru separate pointers */
  YY_parse_STYPE *yyvs = yyvsa;     /*  to allow yyoverflow to reallocate them elsewhere */

#ifdef YY_parse_LSP_NEEDED
  YY_parse_LTYPE yylsa[YYINITDEPTH];        /*  the location stack                  */
  YY_parse_LTYPE *yyls = yylsa;
  YY_parse_LTYPE *yylsp;

#define YYPOPSTACK   (yyvsp--, yyssp--, yylsp--)
#else
#define YYPOPSTACK   (yyvsp--, yyssp--)
#endif

  int yystacksize = YYINITDEPTH;

#ifdef YY_parse_PURE
  int YY_parse_CHAR;
  YY_parse_STYPE YY_parse_LVAL;
  int YY_parse_NERRS;
#ifdef YY_parse_LSP_NEEDED
  YY_parse_LTYPE YY_parse_LLOC;
#endif
#endif

  YY_parse_STYPE yyval;             /*  the variable used to return         */
				/*  semantic values from the action     */
				/*  routines                            */

  int yylen;
/* start loop, in which YYGOTO may be used. */
YYBEGINGOTO

#if YY_parse_DEBUG != 0
  if (YY_parse_DEBUG_FLAG)
    fprintf(stderr, "Starting parse\n");
#endif
  yystate = 0;
  yyerrstatus = 0;
  YY_parse_NERRS = 0;
  YY_parse_CHAR = YYEMPTY;          /* Cause a token to be read.  */

  /* Initialize stack pointers.
     Waste one element of value and location stack
     so that they stay on the same level as the state stack.
     The wasted elements are never initialized.  */

  yyssp = yyss - 1;
  yyvsp = yyvs;
#ifdef YY_parse_LSP_NEEDED
  yylsp = yyls;
#endif

/* Push a new state, which is found in  yystate  .  */
/* In all cases, when you get here, the value and location stacks
   have just been pushed. so pushing a state here evens the stacks.  */
YYLABEL(yynewstate)

  *++yyssp = yystate;

  if (yyssp >= yyss + yystacksize - 1)
    {
      /* Give user a chance to reallocate the stack */
      /* Use copies of these so that the &'s don't force the real ones into memory. */
      YY_parse_STYPE *yyvs1 = yyvs;
      short *yyss1 = yyss;
#ifdef YY_parse_LSP_NEEDED
      YY_parse_LTYPE *yyls1 = yyls;
#endif

      /* Get the current used size of the three stacks, in elements.  */
      int size = yyssp - yyss + 1;

#ifdef yyoverflow
      /* Each stack pointer address is followed by the size of
	 the data in use in that stack, in bytes.  */
#ifdef YY_parse_LSP_NEEDED
      /* This used to be a conditional around just the two extra args,
	 but that might be undefined if yyoverflow is a macro.  */
      yyoverflow("parser stack overflow",
		 &yyss1, size * sizeof (*yyssp),
		 &yyvs1, size * sizeof (*yyvsp),
		 &yyls1, size * sizeof (*yylsp),
		 &yystacksize);
#else
      yyoverflow("parser stack overflow",
		 &yyss1, size * sizeof (*yyssp),
		 &yyvs1, size * sizeof (*yyvsp),
		 &yystacksize);
#endif

      yyss = yyss1; yyvs = yyvs1;
#ifdef YY_parse_LSP_NEEDED
      yyls = yyls1;
#endif
#else /* no yyoverflow */
      /* Extend the stack our own way.  */
      if (yystacksize >= YYMAXDEPTH)
	{
	  YY_parse_ERROR("parser stack overflow");
	  __ALLOCA_return(2);
	}
      yystacksize *= 2;
      if (yystacksize > YYMAXDEPTH)
	yystacksize = YYMAXDEPTH;
      yyss = (short *) __ALLOCA_alloca (yystacksize * sizeof (*yyssp));
      __yy_bcopy ((char *)yyss1, (char *)yyss, size * sizeof (*yyssp));
      __ALLOCA_free(yyss1,yyssa);
      yyvs = (YY_parse_STYPE *) __ALLOCA_alloca (yystacksize * sizeof (*yyvsp));
      __yy_bcopy ((char *)yyvs1, (char *)yyvs, size * sizeof (*yyvsp));
      __ALLOCA_free(yyvs1,yyvsa);
#ifdef YY_parse_LSP_NEEDED
      yyls = (YY_parse_LTYPE *) __ALLOCA_alloca (yystacksize * sizeof (*yylsp));
      __yy_bcopy ((char *)yyls1, (char *)yyls, size * sizeof (*yylsp));
      __ALLOCA_free(yyls1,yylsa);
#endif
#endif /* no yyoverflow */

      yyssp = yyss + size - 1;
      yyvsp = yyvs + size - 1;
#ifdef YY_parse_LSP_NEEDED
      yylsp = yyls + size - 1;
#endif

#if YY_parse_DEBUG != 0
      if (YY_parse_DEBUG_FLAG)
	fprintf(stderr, "Stack size increased to %d\n", yystacksize);
#endif

      if (yyssp >= yyss + yystacksize - 1)
	YYABORT;
    }

#if YY_parse_DEBUG != 0
  if (YY_parse_DEBUG_FLAG)
    fprintf(stderr, "Entering state %d\n", yystate);
#endif

  YYGOTO(yybackup);
YYLABEL(yybackup)

/* Do appropriate processing given the current state.  */
/* Read a lookahead token if we need one and don't already have one.  */
/* YYLABEL(yyresume) */

  /* First try to decide what to do without reference to lookahead token.  */

  yyn = yypact[yystate];
  if (yyn == YYFLAG)
    YYGOTO(yydefault);

  /* Not known => get a lookahead token if don't already have one.  */

  /* yychar is either YYEMPTY or YYEOF
     or a valid token in external form.  */

  if (YY_parse_CHAR == YYEMPTY)
    {
#if YY_parse_DEBUG != 0
      if (YY_parse_DEBUG_FLAG)
	fprintf(stderr, "Reading a token: ");
#endif
      YY_parse_CHAR = YYLEX;
    }

  /* Convert token to internal form (in yychar1) for indexing tables with */

  if (YY_parse_CHAR <= 0)           /* This means end of input. */
    {
      yychar1 = 0;
      YY_parse_CHAR = YYEOF;                /* Don't call YYLEX any more */

#if YY_parse_DEBUG != 0
      if (YY_parse_DEBUG_FLAG)
	fprintf(stderr, "Now at end of input.\n");
#endif
    }
  else
    {
      yychar1 = YYTRANSLATE(YY_parse_CHAR);

#if YY_parse_DEBUG != 0
      if (YY_parse_DEBUG_FLAG)
	{
	  fprintf (stderr, "Next token is %d (%s", YY_parse_CHAR, yytname[yychar1]);
	  /* Give the individual parser a way to print the precise meaning
	     of a token, for further debugging info.  */
#ifdef YYPRINT
	  YYPRINT (stderr, YY_parse_CHAR, YY_parse_LVAL);
#endif
	  fprintf (stderr, ")\n");
	}
#endif
    }

  yyn += yychar1;
  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != yychar1)
    YYGOTO(yydefault);

  yyn = yytable[yyn];

  /* yyn is what to do for this token type in this state.
     Negative => reduce, -yyn is rule number.
     Positive => shift, yyn is new state.
       New state is final state => don't bother to shift,
       just return success.
     0, or most negative number => error.  */

  if (yyn < 0)
    {
      if (yyn == YYFLAG)
	YYGOTO(yyerrlab);
      yyn = -yyn;
      YYGOTO(yyreduce);
    }
  else if (yyn == 0)
    YYGOTO(yyerrlab);

  if (yyn == YYFINAL)
    YYACCEPT;

  /* Shift the lookahead token.  */

#if YY_parse_DEBUG != 0
  if (YY_parse_DEBUG_FLAG)
    fprintf(stderr, "Shifting token %d (%s), ", YY_parse_CHAR, yytname[yychar1]);
#endif

  /* Discard the token being shifted unless it is eof.  */
  if (YY_parse_CHAR != YYEOF)
    YY_parse_CHAR = YYEMPTY;

  *++yyvsp = YY_parse_LVAL;
#ifdef YY_parse_LSP_NEEDED
  *++yylsp = YY_parse_LLOC;
#endif

  /* count tokens shifted since error; after three, turn off error status.  */
  if (yyerrstatus) yyerrstatus--;

  yystate = yyn;
  YYGOTO(yynewstate);

/* Do the default action for the current state.  */
YYLABEL(yydefault)

  yyn = yydefact[yystate];
  if (yyn == 0)
    YYGOTO(yyerrlab);

/* Do a reduction.  yyn is the number of a rule to reduce with.  */
YYLABEL(yyreduce)
  yylen = yyr2[yyn];
  if (yylen > 0)
    yyval = yyvsp[1-yylen]; /* implement default value of the action */

#if YY_parse_DEBUG != 0
  if (YY_parse_DEBUG_FLAG)
    {
      int i;

      fprintf (stderr, "Reducing via rule %d (line %d), ",
	       yyn, yyrline[yyn]);

      /* Print the symbols being reduced, and their result.  */
      for (i = yyprhs[yyn]; yyrhs[i] > 0; i++)
	fprintf (stderr, "%s ", yytname[yyrhs[i]]);
      fprintf (stderr, " -> %s\n", yytname[yyr1[yyn]]);
    }
#endif


 #line 839 "/usr/share/bison++/bison.cc"

  switch (yyn) {

case 1:
#line 54 "parser.y"
{ display_symbol_table();printf("Valid syntax\n"); YYACCEPT; ;
    break;}
case 6:
#line 63 "parser.y"
{printf("New variable decleration!\n");;
    break;}
case 7:
#line 63 "parser.y"
{printf("Finished Variable decleration!\n");isDecl=0;;
    break;}
case 10:
#line 71 "parser.y"
{
		printf("%s\n","Assignment while decleration!");
		if(isDecl){
			printf("Declaring var %s...\n",yyvsp[-2].varname);
			symbol* node = declare_variable(yyvsp[-2].varname);

			if(!node){
				yyerror("[ERROR]:Variable already declared!");
			}
			else{
				printf("Declared: %s\n",node->name);
				//if running datattype is int
				if(*currDatatype==2){
					temp = (char*)malloc(sizeof(char)*100);
					intToString(yyvsp[0].ival);
					node->val = temp;
				}
				//if running datatype is float
				else if(*currDatatype==3){
					temp = (char*)malloc(sizeof(char)*100);
					floatToString(yyvsp[0].fval);
					node->val = temp;
				}
			}
		}
;
    break;}
case 11:
#line 97 "parser.y"
{
			 	printf("%s\n","[DEBUG]:Reduction of T_ID to V");
			 	//if we are declaring variables like int x;
				if(isDecl){
					symbol* node = declare_variable(yyvsp[0].varname);
					if(node==NULL){
						yyerror("[ERROR]:Variable already declared!");
					}
					else{
						printf("Declared: %s\n",node->name);
					}	
				}
				else{
					//if we are using to terminate expressions like E+E
					//search if the variable is declerared already
					symbol* node = check_symbol_table(yyval.varname,currScope);
					if(node==NULL){
						yyerror("[ERROR]:Variable not declared!");
					}
				}
		;
    break;}
case 12:
#line 120 "parser.y"
{isDecl=1;typTrack(2);/*printf("Assigned INT\n")*/;;
    break;}
case 13:
#line 121 "parser.y"
{isDecl=1;typTrack(3);/*printf("Assigned FLOAT\n")*/;;
    break;}
case 14:
#line 122 "parser.y"
{isDecl=1;typTrack(4);/*printf("Assigned DOUBLE\n")*/;;
    break;}
case 15:
#line 123 "parser.y"
{isDecl=1;typTrack(1);/*printf("Assigned CHAR\n")*/;;
    break;}
case 16:
#line 127 "parser.y"
{
	printf("%s\n","Assignment of val to var");
	//check if declared in the symbol table
	printf("Checking for %s,%d\n",yyvsp[-2].varname,currScope);
	symbol* variable = check_symbol_table(yyvsp[-2].varname,currScope);
	if(!variable){
		yyerror("[ERROR]:Variable not declared!");
	}else{
		if(*currDatatype==2){
			printf("To assign val: %d to %s\n",yyvsp[0].ival,yyvsp[-2].varname);
			//weird error if i dont do this...
			temp2 = (char*)malloc(sizeof(char)*100);
			strcpy(temp2,yyvsp[-2].varname);
			yyvsp[-2].ival = yyvsp[0].ival;
			temp = (char*)malloc(sizeof(char)*100);
			intToString(yyvsp[0].ival);
			printf("Converted from int to string %s\n",temp);
			
			int res = insert_value_to_name(temp2,temp,currScope);
			if(res){
				printf("Assigned val in sym table\n");
			}else{
				printf("Var undeclared!\n");
			}
		}
		else if(*currDatatype==3){
			temp2 = (char*)malloc(sizeof(char)*100);
			strcpy(temp2,yyvsp[-2].varname);
			yyvsp[-2].fval = yyvsp[0].fval;
			temp = (char*)malloc(sizeof(char)*100);
			floatToString(yyvsp[0].fval);
			insert_value_to_name(temp2,temp,currScope);
		}
	}
;
    break;}
case 18:
#line 165 "parser.y"
{
			   	if(*currDatatype==2){
					   yyval.ival = yyvsp[0].ival;
					   printf("Reduction of E to Expr: %d\n",yyval.ival);
				}
				else if(*currDatatype==3){
					yyval.fval = yyvsp[0].fval;
				}
		   ;
    break;}
case 19:
#line 176 "parser.y"
{
	printf("Addition expression called!\n");
	printf("Currdatatype: %d\n",*currDatatype);
	if(*currDatatype==2){
		int sum =0;
		printf("Args %d,%d\n",yyvsp[-2].ival,yyvsp[0].ival);
		sum = yyvsp[-2].ival+yyvsp[0].ival;
		printf("The Sum obtained from expression is %d\n",sum);
		yyval.ival = sum;
	}
;
    break;}
case 20:
#line 187 "parser.y"
{
		if(*currDatatype==2){
			yyval.ival= yyvsp[-2].ival-yyvsp[0].ival;
		}
		else if(*currDatatype==3){
			yyval.fval= yyvsp[-2].fval-yyvsp[0].fval;
		}
	;
    break;}
case 21:
#line 195 "parser.y"
{
		printf("Reduction of T to E\n");
		if(*currDatatype==2){
			yyval.ival = yyvsp[0].ival;
		}
		else if(*currDatatype==3){
			yyval.fval = yyvsp[0].fval;
		}
	;
    break;}
case 22:
#line 207 "parser.y"
{
	if(*currDatatype==1){
		yyerror("[ERROR}:Cannot do mul for string!");
	}
	else if(*currDatatype==2){
		yyval.ival = (int)yyvsp[-2].ival*(int)yyvsp[0].ival;
	}
	else if(*currDatatype==3){
		yyval.fval = (float)yyvsp[-2].fval*(float)yyvsp[0].fval;
	}
;
    break;}
case 23:
#line 218 "parser.y"
{
		if(*currDatatype==1){
			yyerror("[ERROR}:Cannot do div for string!");
		}
		else{
			//lower grammar rules will take care to supply $1 and $3 with ivals and not fvals.
			if(*currDatatype==2){
				yyval.ival = (int)yyvsp[-2].ival/(int)yyvsp[0].ival;
			}
			//lower grammar rules will supply $1 and $3 with fvals and not ivals
			else if(*currDatatype==3){
				yyval.fval = (float)yyvsp[-2].fval/(float)yyvsp[0].fval;
			}
		}
	;
    break;}
case 24:
#line 233 "parser.y"
{
		printf("Reduction of F to T\n");
		if(*currDatatype==2){
			yyval.ival = yyvsp[0].ival;
		}
		else if(*currDatatype==3){
			yyval.fval = yyvsp[0].fval;
		}
	;
    break;}
case 25:
#line 244 "parser.y"
{
	yyval = yyvsp[-1];
;
    break;}
case 26:
#line 247 "parser.y"
{
		printf("T_ID of var %s called\n",yyvsp[0].varname);
		symbol* variable = check_symbol_table(yyvsp[0].varname,currScope);
		if(variable && variable->val){
			printf("%s\n","found Entry!!");
			printf("%s.val=%s\n",variable->name,variable->val);
			//running ie context datatype==int
			if(*currDatatype==2){
				//if variable is float convert to int
				if(variable->type==3){
					printf("Float to int :(\n");
					yyval.ival = (int)atof(variable->val);
				}
				//if variable is int,copy it
				else if(variable->type==2){
					printf("Int to int :)\n");
					yyval.ival = atoi(variable->val);
				}
				printf("T_ID reduction to F=%d\n",yyval.ival);
			}
			//running datatype is float
			else if(*currDatatype==3){
				//if variable type is int,typecast
				if(variable->type==2){
					yyval.fval = (float)atoi(variable->val);
				}else if(variable->type==3){
					yyval.fval = atof(variable->val);
				}
			}
		}
	;
    break;}
case 27:
#line 278 "parser.y"
{
		if(*currDatatype==2){
			printf("Integer Constant: %d\n",atoi(yyvsp[0].number));
			yyval.ival = atoi(yyvsp[0].number);
		}
		else if(*currDatatype==3){
			yyval.fval = atof(yyvsp[0].number);
		}
		printf("Reduction of T_NUM to F\n");
	;
    break;}
case 28:
#line 288 "parser.y"
{
		if(*currDatatype==1){
			yyval.cval = yyvsp[0].cval;
		}
		else{
			if(*currDatatype==2){
				yyerror("[ERROR:] type mismatch! Cant assign string to int type");
			}else{
				yyerror("[ERROR:] type mismatch! Cant assign string to float type");
			}
		}
	;
    break;}
case 35:
#line 312 "parser.y"
{currScope = incrScope();;
    break;}
case 36:
#line 316 "parser.y"
{currScope = decrScope();;
    break;}
case 44:
#line 331 "parser.y"
{currScope = incrScope();;
    break;}
case 45:
#line 333 "parser.y"
{currScope=decrScope();;
    break;}
}

#line 839 "/usr/share/bison++/bison.cc"
   /* the action file gets copied in in place of this dollarsign  */
  yyvsp -= yylen;
  yyssp -= yylen;
#ifdef YY_parse_LSP_NEEDED
  yylsp -= yylen;
#endif

#if YY_parse_DEBUG != 0
  if (YY_parse_DEBUG_FLAG)
    {
      short *ssp1 = yyss - 1;
      fprintf (stderr, "state stack now");
      while (ssp1 != yyssp)
	fprintf (stderr, " %d", *++ssp1);
      fprintf (stderr, "\n");
    }
#endif

  *++yyvsp = yyval;

#ifdef YY_parse_LSP_NEEDED
  yylsp++;
  if (yylen == 0)
    {
      yylsp->first_line = YY_parse_LLOC.first_line;
      yylsp->first_column = YY_parse_LLOC.first_column;
      yylsp->last_line = (yylsp-1)->last_line;
      yylsp->last_column = (yylsp-1)->last_column;
      yylsp->text = 0;
    }
  else
    {
      yylsp->last_line = (yylsp+yylen-1)->last_line;
      yylsp->last_column = (yylsp+yylen-1)->last_column;
    }
#endif

  /* Now "shift" the result of the reduction.
     Determine what state that goes to,
     based on the state we popped back to
     and the rule number reduced by.  */

  yyn = yyr1[yyn];

  yystate = yypgoto[yyn - YYNTBASE] + *yyssp;
  if (yystate >= 0 && yystate <= YYLAST && yycheck[yystate] == *yyssp)
    yystate = yytable[yystate];
  else
    yystate = yydefgoto[yyn - YYNTBASE];

  YYGOTO(yynewstate);

YYLABEL(yyerrlab)   /* here on detecting error */

  if (! yyerrstatus)
    /* If not already recovering from an error, report this error.  */
    {
      ++YY_parse_NERRS;

#ifdef YY_parse_ERROR_VERBOSE
      yyn = yypact[yystate];

      if (yyn > YYFLAG && yyn < YYLAST)
	{
	  int size = 0;
	  char *msg;
	  int x, count;

	  count = 0;
	  /* Start X at -yyn if nec to avoid negative indexes in yycheck.  */
	  for (x = (yyn < 0 ? -yyn : 0);
	       x < (sizeof(yytname) / sizeof(char *)); x++)
	    if (yycheck[x + yyn] == x)
	      size += strlen(yytname[x]) + 15, count++;
	  msg = (char *) malloc(size + 15);
	  if (msg != 0)
	    {
	      strcpy(msg, "parse error");

	      if (count < 5)
		{
		  count = 0;
		  for (x = (yyn < 0 ? -yyn : 0);
		       x < (sizeof(yytname) / sizeof(char *)); x++)
		    if (yycheck[x + yyn] == x)
		      {
			strcat(msg, count == 0 ? ", expecting `" : " or `");
			strcat(msg, yytname[x]);
			strcat(msg, "'");
			count++;
		      }
		}
	      YY_parse_ERROR(msg);
	      free(msg);
	    }
	  else
	    YY_parse_ERROR ("parse error; also virtual memory exceeded");
	}
      else
#endif /* YY_parse_ERROR_VERBOSE */
	YY_parse_ERROR("parse error");
    }

  YYGOTO(yyerrlab1);
YYLABEL(yyerrlab1)   /* here on error raised explicitly by an action */

  if (yyerrstatus == 3)
    {
      /* if just tried and failed to reuse lookahead token after an error, discard it.  */

      /* return failure if at end of input */
      if (YY_parse_CHAR == YYEOF)
	YYABORT;

#if YY_parse_DEBUG != 0
      if (YY_parse_DEBUG_FLAG)
	fprintf(stderr, "Discarding token %d (%s).\n", YY_parse_CHAR, yytname[yychar1]);
#endif

      YY_parse_CHAR = YYEMPTY;
    }

  /* Else will try to reuse lookahead token
     after shifting the error token.  */

  yyerrstatus = 3;              /* Each real token shifted decrements this */

  YYGOTO(yyerrhandle);

YYLABEL(yyerrdefault)  /* current state does not do anything special for the error token. */

#if 0
  /* This is wrong; only states that explicitly want error tokens
     should shift them.  */
  yyn = yydefact[yystate];  /* If its default is to accept any token, ok.  Otherwise pop it.*/
  if (yyn) YYGOTO(yydefault);
#endif

YYLABEL(yyerrpop)   /* pop the current state because it cannot handle the error token */

  if (yyssp == yyss) YYABORT;
  yyvsp--;
  yystate = *--yyssp;
#ifdef YY_parse_LSP_NEEDED
  yylsp--;
#endif

#if YY_parse_DEBUG != 0
  if (YY_parse_DEBUG_FLAG)
    {
      short *ssp1 = yyss - 1;
      fprintf (stderr, "Error: state stack now");
      while (ssp1 != yyssp)
	fprintf (stderr, " %d", *++ssp1);
      fprintf (stderr, "\n");
    }
#endif

YYLABEL(yyerrhandle)

  yyn = yypact[yystate];
  if (yyn == YYFLAG)
    YYGOTO(yyerrdefault);

  yyn += YYTERROR;
  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != YYTERROR)
    YYGOTO(yyerrdefault);

  yyn = yytable[yyn];
  if (yyn < 0)
    {
      if (yyn == YYFLAG)
	YYGOTO(yyerrpop);
      yyn = -yyn;
      YYGOTO(yyreduce);
    }
  else if (yyn == 0)
    YYGOTO(yyerrpop);

  if (yyn == YYFINAL)
    YYACCEPT;

#if YY_parse_DEBUG != 0
  if (YY_parse_DEBUG_FLAG)
    fprintf(stderr, "Shifting error token, ");
#endif

  *++yyvsp = YY_parse_LVAL;
#ifdef YY_parse_LSP_NEEDED
  *++yylsp = YY_parse_LLOC;
#endif

  yystate = yyn;
  YYGOTO(yynewstate);
/* end loop, in which YYGOTO may be used. */
  YYENDGOTO
}

/* END */

 #line 1038 "/usr/share/bison++/bison.cc"
#line 338 "parser.y"


/* error handling function */
void yyerror(char* s)
{
	printf("Error :%s at %d \n",s,yylineno);
}


int main(int argc, char* argv[])
{
	//printf("Running Parser!\n");
	init_table();
	//printf("Table assigned too!\n");
	yyparse();
	/* display final symbol table*/
	return 0;
}

int incrScope(){
	currScope+=1;
	return currScope;
}

int decrScope(){
	currScope-=1;
	if(currScope<=0){
		currScope = 1;
	}
	return currScope;
}

//assign the data type of variable decleration
void typTrack(int type){
	if(currDatatype==NULL){
		currDatatype = malloc(sizeof(int));
	}
	*currDatatype = type;
	//printf("Finished creating dtype!\n");
}

//track the line number of variable decleration
void lineTrack(int lno){
	if(currLineNumber==NULL){
		currLineNumber = malloc(sizeof(int));
	}
	*currLineNumber = lno;
	//printf("Finished asigning lineno!\n");
}

//function to insert variable decleration with type and line number into symbol table
symbol* declare_variable(char* varname){
	//printf("Processing to make sym table entry...\n");
	lineTrack(yylineno);
	symbol* res = insert_into_table(varname,size_of(*currDatatype),*currDatatype,*currLineNumber,currScope);
	if(res==NULL){
		yyerror("[ERROR] Variable already declared!");
		return NULL;
	}
	else{
		printf("%s\n","Declared var!");
		return res;
	}
}

//function to return size of datatype
int size_of(int type){
	int size = 0;
	switch(*currDatatype){
		case 1:
			size = 4;
			break;
		case 2:
			size = 1;
			break;
		case 3:
			size = 8;
			break;
		case 4:
			size=16;
			break;
		default:
			size = 4;
			break;
	}
	return size;		
}

void intToString(int num){
	sprintf(temp,"%d",num);
}

void floatToString(float num){
	sprintf(temp,"%f",num);
}